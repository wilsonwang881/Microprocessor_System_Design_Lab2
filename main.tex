\documentclass[11pt,letterpaper,titlepage]{article}

\usepackage{geometry}
\geometry{left=2cm,right=2cm,top=2cm,bottom=3cm}

\usepackage{setspace}
\onehalfspacing

\usepackage{multicol}
\setlength{\columnsep}{3em}

\usepackage{booktabs}

\usepackage[table,x11names]{xcolor}

\usepackage{multirow}

\usepackage{pgfgantt}

\usepackage{listings}

\usepackage{xcolor}
\definecolor{vgreen}{RGB}{104,180,104}
\definecolor{vblue}{RGB}{49,49,255}
\definecolor{vorange}{RGB}{255,143,102}

\lstdefinestyle{verilog-style}
{
    language=Verilog,
    basicstyle=\small\ttfamily,
    keywordstyle=\color{vblue},
    identifierstyle=\color{black},
    commentstyle=\color{vgreen},
    % numbers=left,
    numberstyle=\tiny\color{black},
    numbersep=11pt,
    tabsize=4,
    moredelim=*[s][\colorIndex]{[}{]},
    literate=*{:}{:}1
}

\lstdefinestyle{txt-style}
{
    basicstyle=\small\ttfamily,
    % numbers=left,
    numbersep=11pt,
    tabsize=4,
    moredelim=*[s][\colorIndex]{[}{]},
    literate=*{:}{:}1
}

\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows, positioning, fit,calc}
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=1pt] (char) {#1};}}
            
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\usepackage{pifont}

\usepackage[toc,page]{appendix}

\pagestyle{empty}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}

\usetikzlibrary{mindmap,trees}
\usepackage{verbatim}

\usepackage{indentfirst}
\setlength{\parindent}{2em}

\usepackage{listings}

% \usepackage{hyperref}
\usepackage{chngcntr}
\counterwithin{section}{part}
\renewcommand\thesection{\arabic{section}}

\usepackage{graphicx}

\usepackage{subcaption}

\usepackage{fancyhdr}

\pagestyle{fancy}
\lhead{}
\rhead{}
\lfoot{ECEN 749 Section 601 Lab 2}
\cfoot{\thepage}
\rfoot{@Lei Wang (Wilson)}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\headwidth}{\textwidth}
\renewcommand{\footrulewidth}{0.4pt}
\newcommand{\RomanNumeralCaps}[1]
    {\MakeUppercase{\romannumeral #1}}

\makeatletter
\newcommand*\@lbracket{[}
\newcommand*\@rbracket{]}
\newcommand*\@colon{:}
\newcommand*\colorIndex{%
    \edef\@temp{\the\lst@token}%
    \ifx\@temp\@lbracket \color{black}%
    \else\ifx\@temp\@rbracket \color{black}%
    \else\ifx\@temp\@colon \color{black}%
    \else \color{vorange}%
    \fi\fi\fi
}
\makeatother

\usepackage{trace}

\begin{document}

\begin{titlepage}
  \centering
	{\scshape\large Texas A\&M University \par}
	\vspace{1cm}
	{\scshape\Large Department of Electrical and Computer Engineering \par}
	\vspace{4cm}
    \vspace{0.5cm}
	{\huge\bfseries ECEN 749 Microprocessor System Design\par}
	\vspace{4cm}
	{\Large Lab 2 Report (Section 601)\par}
	\vspace{1cm}
	{\Large Student: Lei Wang (Wilson)\par}
	\vspace{1cm}
	{\Large UIN: 829009485\par}
	\vspace{1cm}
	{\Large Instructor: Dr. Paul V. Gratz\par}
	\vspace{4cm}
	\vfill

  % Bottom of the page
	{\large Submitted: February 4th, 2020 \par}

\end{titlepage}

\newpage

\tableofcontents{}

\newpage

\section{Introduction}

The second lab session for ECEN 749 aims at familiarizing the students with the operation of running C program on a processor that is running on FPGA. The lab uses the Xilinx Vivado Design Suite to design the hardware and the Xilinx SDK to program FPGA and run C program on FPGA after FPGA has been configured according to the hardware design. The lab consists of two experiments:

\begin{table}[ht]
\centering
\begin{tabular}{@{}cl@{}}
\toprule
Experiment & Description                      \\ \midrule
1          & LED counter with console log     \\ \midrule
2          & GPIO operations with console log \\ \bottomrule
\end{tabular}
\caption{Experiments for lab session 2.}
\end{table}

Students are expected to be able to import IPs and configure them properly according to the requirement.

\section{Procedure}

\section{Results}

\section{Conclusion}

Q: In the first part of the lab, we created a delay function by implementing a counter. The goal was to update the LEDs approximately every second as we did in the previous lab. Compare the count value in this lab to the count value you used as a delay in the previous lab. If they are different, explain why? Can you determine approximately how many clock cycles are required to execute one iteration of the delay for-loop? If so, how many?

A: The count value used in the delay function in this lab is 10000000 as in the previous lab, the number is 125000000. The value used in this lab is smaller than the one used in the previous lab. In the previous lab, 

Q: Why is the count variable in our software delay declared as volatile?

A:

Q: What does the while(1) expression in our code do?

A: It is an infinite loop that executes the code in the loop infinitely many times until the program is terminated by the user or due to exceptions. We place our code, i.e. increment the counter, display the counter value on LED and print counter value in the terminal, or as described in the second part of the lab, for handling switch and button events, in the infinite loop.

Q: Compare and contrast this lab with the previous lab. Which implementation do you feel is easier? What are the advantages and disadvantages associated with a purely software implementation such as this when compared to a purely hardware implementation such as the previous lab?

A: The implementation in this lab feels easier. The advantages of using software approach is the rich library ecosystem available to use, though Verilog does have libraries, C libraries are much easier to use for a person like me who has some experience with coding but not so much with hardware design. The logic behind C programming is sequential while in Verilog, parallel operations can exist, which makes it difficult to understand and debug. Verilog does not have data types like int or char but pure bytes. Coding in pure bytes instead of meaningful data types can be difficult to understand intuitively.

The disadvantage of using purely software approach is such approach relies on a mature processor system such as the Microblaze soft processor running on FPGA. Without such processor, a purely software implementation is impossible as it lacks the ability to communicate with the hardware. A software approach can consume a significant chunk of the hardware resource available on the FPGA board, even the software is very simple and does not require a powerful processor to run. A purely hardware approach can reduce the resource usage since it does not require a complicated soft processor. Since a software approach needs a processor, the setup process can be prone to errors compared with a hardware approach, which involves fewer steps to setup and run.

\newpage

\begin{appendices}

\end{appendices}

\end{document}
